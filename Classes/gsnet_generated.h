    // automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_
#define FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_

#include <mflatbuffers/flatbuffers.h>

namespace GameEvent {
    
    struct CLConnection;
    
    struct SVConnectionStatus;
    
    struct SVPlayerConnected;
    
    struct SVHeroPickStage;
    
    struct CLHeroPick;
    
    struct SVHeroPick;
    
    struct CLReadyToStart;
    
    struct SVReadyToStart;
    
    struct SVGenerateMap;
    
    struct CLMapGenerated;
    
    struct SVGameStart;
    
    struct CLActionMove;
    
    struct SVActionMove;
    
    struct CLActionItem;
    
    struct SVActionItem;
    
    struct MageTeleport;
    
    struct MageFreeze;
    
    struct Spell;
    
    struct CLActionSpell;
    
    struct SVActionSpell;
    
    struct CLActionAttack;
    
    struct SVActionAttack;
    
    struct CLActionDuel;
    
    struct SVActionDuel;
    
    struct CLActionMap;
    
    struct SVActionMap;
    
    struct SVSpawnPlayer;
    
    struct SVSpawnMonster;
    
    struct SVRespawnPlayer;
    
    struct SVSpawnItem;
    
    struct SVSpawnConstr;
    
    struct SVGameEnd;
    
    struct Message;
    
    enum ConnectionStatus {
        ConnectionStatus_ACCEPTED = 0,
        ConnectionStatus_REFUSED = 1,
        ConnectionStatus_MIN = ConnectionStatus_ACCEPTED,
        ConnectionStatus_MAX = ConnectionStatus_REFUSED
    };
    
    inline const char **EnumNamesConnectionStatus() {
        static const char *names[] = {
            "ACCEPTED",
            "REFUSED",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesConnectionStatus()[index];
    }
    
    enum HeroType {
        HeroType_WARRIOR = 0,
        HeroType_MAGE = 1,
        HeroType_ROGUE = 2,
        HeroType_PRIEST = 3,
        HeroType_MIN = HeroType_WARRIOR,
        HeroType_MAX = HeroType_PRIEST
    };
    
    inline const char **EnumNamesHeroType() {
        static const char *names[] = {
            "WARRIOR",
            "MAGE",
            "ROGUE",
            "PRIEST",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameHeroType(HeroType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesHeroType()[index];
    }
    
    enum ActionItemType {
        ActionItemType_TAKE = 0,
        ActionItemType_DROP = 1,
        ActionItemType_USE = 2,
        ActionItemType_MIN = ActionItemType_TAKE,
        ActionItemType_MAX = ActionItemType_USE
    };
    
    inline const char **EnumNamesActionItemType() {
        static const char *names[] = {
            "TAKE",
            "DROP",
            "USE",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameActionItemType(ActionItemType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesActionItemType()[index];
    }
    
    enum Spells {
        Spells_NONE = 0,
        Spells_MageTeleport = 1,
        Spells_MageFreeze = 2,
        Spells_MIN = Spells_NONE,
        Spells_MAX = Spells_MageFreeze
    };
    
    inline const char **EnumNamesSpells() {
        static const char *names[] = {
            "NONE",
            "MageTeleport",
            "MageFreeze",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameSpells(Spells e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesSpells()[index];
    }
    
    template<typename T> struct SpellsTraits {
        static const Spells enum_value = Spells_NONE;
    };
    
    template<> struct SpellsTraits<MageTeleport> {
        static const Spells enum_value = Spells_MageTeleport;
    };
    
    template<> struct SpellsTraits<MageFreeze> {
        static const Spells enum_value = Spells_MageFreeze;
    };
    
    bool VerifySpells(flatbuffers::Verifier &verifier, const void *obj, Spells type);
    bool VerifySpellsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
    
    enum ActionDuelType {
        ActionDuelType_STARTED = 0,
        ActionDuelType_ATTACK = 1,
        ActionDuelType_ESCAPE = 2,
        ActionDuelType_KILL = 3,
        ActionDuelType_MIN = ActionDuelType_STARTED,
        ActionDuelType_MAX = ActionDuelType_KILL
    };
    
    inline const char **EnumNamesActionDuelType() {
        static const char *names[] = {
            "STARTED",
            "ATTACK",
            "ESCAPE",
            "KILL",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameActionDuelType(ActionDuelType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesActionDuelType()[index];
    }
    
    enum ActionMapType {
        ActionMapType_CREATE_BLOCK = 0,
        ActionMapType_DESTROY_BLOCK = 1,
        ActionMapType_MIN = ActionMapType_CREATE_BLOCK,
        ActionMapType_MAX = ActionMapType_DESTROY_BLOCK
    };
    
    inline const char **EnumNamesActionMapType() {
        static const char *names[] = {
            "CREATE_BLOCK",
            "DESTROY_BLOCK",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameActionMapType(ActionMapType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesActionMapType()[index];
    }
    
    enum ItemType {
        ItemType_KEY = 0,
        ItemType_SWORD = 1,
        ItemType_MIN = ItemType_KEY,
        ItemType_MAX = ItemType_SWORD
    };
    
    inline const char **EnumNamesItemType() {
        static const char *names[] = {
            "KEY",
            "SWORD",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameItemType(ItemType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesItemType()[index];
    }
    
    enum ConstrType {
        ConstrType_DOOR = 0,
        ConstrType_GRAVEYARD = 1,
        ConstrType_SWAMP = 2,
        ConstrType_MIN = ConstrType_DOOR,
        ConstrType_MAX = ConstrType_SWAMP
    };
    
    inline const char **EnumNamesConstrType() {
        static const char *names[] = {
            "DOOR",
            "GRAVEYARD",
            "SWAMP",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameConstrType(ConstrType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesConstrType()[index];
    }
    
    enum Events {
        Events_NONE = 0,
        Events_CLConnection = 1,
        Events_SVConnectionStatus = 2,
        Events_SVPlayerConnected = 3,
        Events_SVHeroPickStage = 4,
        Events_CLHeroPick = 5,
        Events_SVHeroPick = 6,
        Events_CLReadyToStart = 7,
        Events_SVReadyToStart = 8,
        Events_SVGenerateMap = 9,
        Events_CLMapGenerated = 10,
        Events_SVGameStart = 11,
        Events_CLActionMove = 12,
        Events_SVActionMove = 13,
        Events_CLActionItem = 14,
        Events_SVActionItem = 15,
        Events_CLActionAttack = 16,
        Events_SVActionAttack = 17,
        Events_CLActionDuel = 18,
        Events_SVActionDuel = 19,
        Events_CLActionSpell = 20,
        Events_SVActionSpell = 21,
        Events_CLActionMap = 22,
        Events_SVActionMap = 23,
        Events_SVSpawnPlayer = 24,
        Events_SVRespawnPlayer = 25,
        Events_SVSpawnMonster = 26,
        Events_SVSpawnItem = 27,
        Events_SVSpawnConstr = 28,
        Events_SVGameEnd = 29,
        Events_MIN = Events_NONE,
        Events_MAX = Events_SVGameEnd
    };
    
    inline const char **EnumNamesEvents() {
        static const char *names[] = {
            "NONE",
            "CLConnection",
            "SVConnectionStatus",
            "SVPlayerConnected",
            "SVHeroPickStage",
            "CLHeroPick",
            "SVHeroPick",
            "CLReadyToStart",
            "SVReadyToStart",
            "SVGenerateMap",
            "CLMapGenerated",
            "SVGameStart",
            "CLActionMove",
            "SVActionMove",
            "CLActionItem",
            "SVActionItem",
            "CLActionAttack",
            "SVActionAttack",
            "CLActionDuel",
            "SVActionDuel",
            "CLActionSpell",
            "SVActionSpell",
            "CLActionMap",
            "SVActionMap",
            "SVSpawnPlayer",
            "SVRespawnPlayer",
            "SVSpawnMonster",
            "SVSpawnItem",
            "SVSpawnConstr",
            "SVGameEnd",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameEvents(Events e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesEvents()[index];
    }
    
    template<typename T> struct EventsTraits {
        static const Events enum_value = Events_NONE;
    };
    
    template<> struct EventsTraits<CLConnection> {
        static const Events enum_value = Events_CLConnection;
    };
    
    template<> struct EventsTraits<SVConnectionStatus> {
        static const Events enum_value = Events_SVConnectionStatus;
    };
    
    template<> struct EventsTraits<SVPlayerConnected> {
        static const Events enum_value = Events_SVPlayerConnected;
    };
    
    template<> struct EventsTraits<SVHeroPickStage> {
        static const Events enum_value = Events_SVHeroPickStage;
    };
    
    template<> struct EventsTraits<CLHeroPick> {
        static const Events enum_value = Events_CLHeroPick;
    };
    
    template<> struct EventsTraits<SVHeroPick> {
        static const Events enum_value = Events_SVHeroPick;
    };
    
    template<> struct EventsTraits<CLReadyToStart> {
        static const Events enum_value = Events_CLReadyToStart;
    };
    
    template<> struct EventsTraits<SVReadyToStart> {
        static const Events enum_value = Events_SVReadyToStart;
    };
    
    template<> struct EventsTraits<SVGenerateMap> {
        static const Events enum_value = Events_SVGenerateMap;
    };
    
    template<> struct EventsTraits<CLMapGenerated> {
        static const Events enum_value = Events_CLMapGenerated;
    };
    
    template<> struct EventsTraits<SVGameStart> {
        static const Events enum_value = Events_SVGameStart;
    };
    
    template<> struct EventsTraits<CLActionMove> {
        static const Events enum_value = Events_CLActionMove;
    };
    
    template<> struct EventsTraits<SVActionMove> {
        static const Events enum_value = Events_SVActionMove;
    };
    
    template<> struct EventsTraits<CLActionItem> {
        static const Events enum_value = Events_CLActionItem;
    };
    
    template<> struct EventsTraits<SVActionItem> {
        static const Events enum_value = Events_SVActionItem;
    };
    
    template<> struct EventsTraits<CLActionAttack> {
        static const Events enum_value = Events_CLActionAttack;
    };
    
    template<> struct EventsTraits<SVActionAttack> {
        static const Events enum_value = Events_SVActionAttack;
    };
    
    template<> struct EventsTraits<CLActionDuel> {
        static const Events enum_value = Events_CLActionDuel;
    };
    
    template<> struct EventsTraits<SVActionDuel> {
        static const Events enum_value = Events_SVActionDuel;
    };
    
    template<> struct EventsTraits<CLActionSpell> {
        static const Events enum_value = Events_CLActionSpell;
    };
    
    template<> struct EventsTraits<SVActionSpell> {
        static const Events enum_value = Events_SVActionSpell;
    };
    
    template<> struct EventsTraits<CLActionMap> {
        static const Events enum_value = Events_CLActionMap;
    };
    
    template<> struct EventsTraits<SVActionMap> {
        static const Events enum_value = Events_SVActionMap;
    };
    
    template<> struct EventsTraits<SVSpawnPlayer> {
        static const Events enum_value = Events_SVSpawnPlayer;
    };
    
    template<> struct EventsTraits<SVRespawnPlayer> {
        static const Events enum_value = Events_SVRespawnPlayer;
    };
    
    template<> struct EventsTraits<SVSpawnMonster> {
        static const Events enum_value = Events_SVSpawnMonster;
    };
    
    template<> struct EventsTraits<SVSpawnItem> {
        static const Events enum_value = Events_SVSpawnItem;
    };
    
    template<> struct EventsTraits<SVSpawnConstr> {
        static const Events enum_value = Events_SVSpawnConstr;
    };
    
    template<> struct EventsTraits<SVGameEnd> {
        static const Events enum_value = Events_SVGameEnd;
    };
    
    bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type);
    bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
    
    struct CLConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_NICKNAME = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        const flatbuffers::String *nickname() const {
            return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
            verifier.Verify(nickname()) &&
            verifier.EndTable();
        }
    };
    
    struct CLConnectionBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLConnection::VT_PLAYER_UID, player_uid, 0);
        }
        void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
            fbb_.AddOffset(CLConnection::VT_NICKNAME, nickname);
        }
        CLConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLConnectionBuilder &operator=(const CLConnectionBuilder &);
        flatbuffers::Offset<CLConnection> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<CLConnection>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLConnection> CreateCLConnection(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t player_uid = 0,
                                                                flatbuffers::Offset<flatbuffers::String> nickname = 0) {
        CLConnectionBuilder builder_(_fbb);
        builder_.add_nickname(nickname);
        builder_.add_player_uid(player_uid);
        return builder_.Finish();
    }
    
    inline flatbuffers::Offset<CLConnection> CreateCLConnectionDirect(
                                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                                      uint32_t player_uid = 0,
                                                                      const char *nickname = nullptr) {
        return CreateCLConnection(
                                  _fbb,
                                  player_uid,
                                  nickname ? _fbb.CreateString(nickname) : 0);
    }
    
    struct SVConnectionStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_STATUS = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        ConnectionStatus status() const {
            return static_cast<ConnectionStatus>(GetField<int8_t>(VT_STATUS, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_STATUS) &&
            verifier.EndTable();
        }
    };
    
    struct SVConnectionStatusBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVConnectionStatus::VT_PLAYER_UID, player_uid, 0);
        }
        void add_status(ConnectionStatus status) {
            fbb_.AddElement<int8_t>(SVConnectionStatus::VT_STATUS, static_cast<int8_t>(status), 0);
        }
        SVConnectionStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVConnectionStatusBuilder &operator=(const SVConnectionStatusBuilder &);
        flatbuffers::Offset<SVConnectionStatus> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<SVConnectionStatus>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVConnectionStatus> CreateSVConnectionStatus(
                                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                                            uint32_t player_uid = 0,
                                                                            ConnectionStatus status = ConnectionStatus_ACCEPTED) {
        SVConnectionStatusBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_status(status);
        return builder_.Finish();
    }
    
    struct SVPlayerConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_NICKNAME = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        const flatbuffers::String *nickname() const {
            return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
            verifier.Verify(nickname()) &&
            verifier.EndTable();
        }
    };
    
    struct SVPlayerConnectedBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVPlayerConnected::VT_PLAYER_UID, player_uid, 0);
        }
        void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
            fbb_.AddOffset(SVPlayerConnected::VT_NICKNAME, nickname);
        }
        SVPlayerConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVPlayerConnectedBuilder &operator=(const SVPlayerConnectedBuilder &);
        flatbuffers::Offset<SVPlayerConnected> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<SVPlayerConnected>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVPlayerConnected> CreateSVPlayerConnected(
                                                                          flatbuffers::FlatBufferBuilder &_fbb,
                                                                          uint32_t player_uid = 0,
                                                                          flatbuffers::Offset<flatbuffers::String> nickname = 0) {
        SVPlayerConnectedBuilder builder_(_fbb);
        builder_.add_nickname(nickname);
        builder_.add_player_uid(player_uid);
        return builder_.Finish();
    }
    
    inline flatbuffers::Offset<SVPlayerConnected> CreateSVPlayerConnectedDirect(
                                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                                uint32_t player_uid = 0,
                                                                                const char *nickname = nullptr) {
        return CreateSVPlayerConnected(
                                       _fbb,
                                       player_uid,
                                       nickname ? _fbb.CreateString(nickname) : 0);
    }
    
    struct SVHeroPickStage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            verifier.EndTable();
        }
    };
    
    struct SVHeroPickStageBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        SVHeroPickStageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVHeroPickStageBuilder &operator=(const SVHeroPickStageBuilder &);
        flatbuffers::Offset<SVHeroPickStage> Finish() {
            const auto end = fbb_.EndTable(start_, 0);
            auto o = flatbuffers::Offset<SVHeroPickStage>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVHeroPickStage> CreateSVHeroPickStage(
                                                                      flatbuffers::FlatBufferBuilder &_fbb) {
        SVHeroPickStageBuilder builder_(_fbb);
        return builder_.Finish();
    }
    
    struct CLHeroPick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_HERO_TYPE = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        HeroType hero_type() const {
            return static_cast<HeroType>(GetField<int8_t>(VT_HERO_TYPE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_HERO_TYPE) &&
            verifier.EndTable();
        }
    };
    
    struct CLHeroPickBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLHeroPick::VT_PLAYER_UID, player_uid, 0);
        }
        void add_hero_type(HeroType hero_type) {
            fbb_.AddElement<int8_t>(CLHeroPick::VT_HERO_TYPE, static_cast<int8_t>(hero_type), 0);
        }
        CLHeroPickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLHeroPickBuilder &operator=(const CLHeroPickBuilder &);
        flatbuffers::Offset<CLHeroPick> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<CLHeroPick>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLHeroPick> CreateCLHeroPick(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t player_uid = 0,
                                                            HeroType hero_type = HeroType_WARRIOR) {
        CLHeroPickBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_hero_type(hero_type);
        return builder_.Finish();
    }
    
    struct SVHeroPick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_HERO_TYPE = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        HeroType hero_type() const {
            return static_cast<HeroType>(GetField<int8_t>(VT_HERO_TYPE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_HERO_TYPE) &&
            verifier.EndTable();
        }
    };
    
    struct SVHeroPickBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVHeroPick::VT_PLAYER_UID, player_uid, 0);
        }
        void add_hero_type(HeroType hero_type) {
            fbb_.AddElement<int8_t>(SVHeroPick::VT_HERO_TYPE, static_cast<int8_t>(hero_type), 0);
        }
        SVHeroPickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVHeroPickBuilder &operator=(const SVHeroPickBuilder &);
        flatbuffers::Offset<SVHeroPick> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<SVHeroPick>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVHeroPick> CreateSVHeroPick(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t player_uid = 0,
                                                            HeroType hero_type = HeroType_WARRIOR) {
        SVHeroPickBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_hero_type(hero_type);
        return builder_.Finish();
    }
    
    struct CLReadyToStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            verifier.EndTable();
        }
    };
    
    struct CLReadyToStartBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLReadyToStart::VT_PLAYER_UID, player_uid, 0);
        }
        CLReadyToStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLReadyToStartBuilder &operator=(const CLReadyToStartBuilder &);
        flatbuffers::Offset<CLReadyToStart> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<CLReadyToStart>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLReadyToStart> CreateCLReadyToStart(
                                                                    flatbuffers::FlatBufferBuilder &_fbb,
                                                                    uint32_t player_uid = 0) {
        CLReadyToStartBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        return builder_.Finish();
    }
    
    struct SVReadyToStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            verifier.EndTable();
        }
    };
    
    struct SVReadyToStartBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVReadyToStart::VT_PLAYER_UID, player_uid, 0);
        }
        SVReadyToStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVReadyToStartBuilder &operator=(const SVReadyToStartBuilder &);
        flatbuffers::Offset<SVReadyToStart> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<SVReadyToStart>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVReadyToStart> CreateSVReadyToStart(
                                                                    flatbuffers::FlatBufferBuilder &_fbb,
                                                                    uint32_t player_uid = 0) {
        SVReadyToStartBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        return builder_.Finish();
    }
    
    struct SVGenerateMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_MAP_W = 4,
            VT_ROOM_W = 6,
            VT_SEED = 8
        };
        uint16_t map_w() const {
            return GetField<uint16_t>(VT_MAP_W, 0);
        }
        uint16_t room_w() const {
            return GetField<uint16_t>(VT_ROOM_W, 0);
        }
        uint32_t seed() const {
            return GetField<uint32_t>(VT_SEED, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint16_t>(verifier, VT_MAP_W) &&
            VerifyField<uint16_t>(verifier, VT_ROOM_W) &&
            VerifyField<uint32_t>(verifier, VT_SEED) &&
            verifier.EndTable();
        }
    };
    
    struct SVGenerateMapBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_map_w(uint16_t map_w) {
            fbb_.AddElement<uint16_t>(SVGenerateMap::VT_MAP_W, map_w, 0);
        }
        void add_room_w(uint16_t room_w) {
            fbb_.AddElement<uint16_t>(SVGenerateMap::VT_ROOM_W, room_w, 0);
        }
        void add_seed(uint32_t seed) {
            fbb_.AddElement<uint32_t>(SVGenerateMap::VT_SEED, seed, 0);
        }
        SVGenerateMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVGenerateMapBuilder &operator=(const SVGenerateMapBuilder &);
        flatbuffers::Offset<SVGenerateMap> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<SVGenerateMap>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVGenerateMap> CreateSVGenerateMap(
                                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                                  uint16_t map_w = 0,
                                                                  uint16_t room_w = 0,
                                                                  uint32_t seed = 0) {
        SVGenerateMapBuilder builder_(_fbb);
        builder_.add_seed(seed);
        builder_.add_room_w(room_w);
        builder_.add_map_w(map_w);
        return builder_.Finish();
    }
    
    struct CLMapGenerated FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            verifier.EndTable();
        }
    };
    
    struct CLMapGeneratedBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLMapGenerated::VT_PLAYER_UID, player_uid, 0);
        }
        CLMapGeneratedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLMapGeneratedBuilder &operator=(const CLMapGeneratedBuilder &);
        flatbuffers::Offset<CLMapGenerated> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<CLMapGenerated>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLMapGenerated> CreateCLMapGenerated(
                                                                    flatbuffers::FlatBufferBuilder &_fbb,
                                                                    uint32_t player_uid = 0) {
        CLMapGeneratedBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        return builder_.Finish();
    }
    
    struct SVGameStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            verifier.EndTable();
        }
    };
    
    struct SVGameStartBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        SVGameStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVGameStartBuilder &operator=(const SVGameStartBuilder &);
        flatbuffers::Offset<SVGameStart> Finish() {
            const auto end = fbb_.EndTable(start_, 0);
            auto o = flatbuffers::Offset<SVGameStart>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVGameStart> CreateSVGameStart(
                                                              flatbuffers::FlatBufferBuilder &_fbb) {
        SVGameStartBuilder builder_(_fbb);
        return builder_.Finish();
    }
    
    struct CLActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_TARGET_UID = 4,
            VT_X = 6,
            VT_Y = 8
        };
        uint32_t target_uid() const {
            return GetField<uint32_t>(VT_TARGET_UID, 0);
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_TARGET_UID) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct CLActionMoveBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_target_uid(uint32_t target_uid) {
            fbb_.AddElement<uint32_t>(CLActionMove::VT_TARGET_UID, target_uid, 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(CLActionMove::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(CLActionMove::VT_Y, y, 0);
        }
        CLActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLActionMoveBuilder &operator=(const CLActionMoveBuilder &);
        flatbuffers::Offset<CLActionMove> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<CLActionMove>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLActionMove> CreateCLActionMove(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t target_uid = 0,
                                                                uint16_t x = 0,
                                                                uint16_t y = 0) {
        CLActionMoveBuilder builder_(_fbb);
        builder_.add_target_uid(target_uid);
        builder_.add_y(y);
        builder_.add_x(x);
        return builder_.Finish();
    }
    
    struct SVActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_TARGET_UID = 4,
            VT_X = 6,
            VT_Y = 8
        };
        uint32_t target_uid() const {
            return GetField<uint32_t>(VT_TARGET_UID, 0);
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_TARGET_UID) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct SVActionMoveBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_target_uid(uint32_t target_uid) {
            fbb_.AddElement<uint32_t>(SVActionMove::VT_TARGET_UID, target_uid, 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVActionMove::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVActionMove::VT_Y, y, 0);
        }
        SVActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVActionMoveBuilder &operator=(const SVActionMoveBuilder &);
        flatbuffers::Offset<SVActionMove> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<SVActionMove>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVActionMove> CreateSVActionMove(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t target_uid = 0,
                                                                uint16_t x = 0,
                                                                uint16_t y = 0) {
        SVActionMoveBuilder builder_(_fbb);
        builder_.add_target_uid(target_uid);
        builder_.add_y(y);
        builder_.add_x(x);
        return builder_.Finish();
    }
    
    struct CLActionItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_ITEM_UID = 6,
            VT_ACT_TYPE = 8
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        uint16_t item_uid() const {
            return GetField<uint16_t>(VT_ITEM_UID, 0);
        }
        ActionItemType act_type() const {
            return static_cast<ActionItemType>(GetField<int8_t>(VT_ACT_TYPE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
            VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
            verifier.EndTable();
        }
    };
    
    struct CLActionItemBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLActionItem::VT_PLAYER_UID, player_uid, 0);
        }
        void add_item_uid(uint16_t item_uid) {
            fbb_.AddElement<uint16_t>(CLActionItem::VT_ITEM_UID, item_uid, 0);
        }
        void add_act_type(ActionItemType act_type) {
            fbb_.AddElement<int8_t>(CLActionItem::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
        }
        CLActionItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLActionItemBuilder &operator=(const CLActionItemBuilder &);
        flatbuffers::Offset<CLActionItem> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<CLActionItem>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLActionItem> CreateCLActionItem(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t player_uid = 0,
                                                                uint16_t item_uid = 0,
                                                                ActionItemType act_type = ActionItemType_TAKE) {
        CLActionItemBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_item_uid(item_uid);
        builder_.add_act_type(act_type);
        return builder_.Finish();
    }
    
    struct SVActionItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_ITEM_UID = 6,
            VT_ACT_TYPE = 8
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        uint16_t item_uid() const {
            return GetField<uint16_t>(VT_ITEM_UID, 0);
        }
        ActionItemType act_type() const {
            return static_cast<ActionItemType>(GetField<int8_t>(VT_ACT_TYPE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
            VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
            verifier.EndTable();
        }
    };
    
    struct SVActionItemBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVActionItem::VT_PLAYER_UID, player_uid, 0);
        }
        void add_item_uid(uint16_t item_uid) {
            fbb_.AddElement<uint16_t>(SVActionItem::VT_ITEM_UID, item_uid, 0);
        }
        void add_act_type(ActionItemType act_type) {
            fbb_.AddElement<int8_t>(SVActionItem::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
        }
        SVActionItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVActionItemBuilder &operator=(const SVActionItemBuilder &);
        flatbuffers::Offset<SVActionItem> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<SVActionItem>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVActionItem> CreateSVActionItem(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t player_uid = 0,
                                                                uint16_t item_uid = 0,
                                                                ActionItemType act_type = ActionItemType_TAKE) {
        SVActionItemBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_item_uid(item_uid);
        builder_.add_act_type(act_type);
        return builder_.Finish();
    }
    
    struct MageTeleport FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_X = 4,
            VT_Y = 6
        };
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct MageTeleportBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(MageTeleport::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(MageTeleport::VT_Y, y, 0);
        }
        MageTeleportBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MageTeleportBuilder &operator=(const MageTeleportBuilder &);
        flatbuffers::Offset<MageTeleport> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<MageTeleport>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MageTeleport> CreateMageTeleport(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint16_t x = 0,
                                                                uint16_t y = 0) {
        MageTeleportBuilder builder_(_fbb);
        builder_.add_y(y);
        builder_.add_x(x);
        return builder_.Finish();
    }
    
    struct MageFreeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_ENEMY_ID = 4
        };
        uint32_t enemy_id() const {
            return GetField<uint32_t>(VT_ENEMY_ID, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_ENEMY_ID) &&
            verifier.EndTable();
        }
    };
    
    struct MageFreezeBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_enemy_id(uint32_t enemy_id) {
            fbb_.AddElement<uint32_t>(MageFreeze::VT_ENEMY_ID, enemy_id, 0);
        }
        MageFreezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MageFreezeBuilder &operator=(const MageFreezeBuilder &);
        flatbuffers::Offset<MageFreeze> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<MageFreeze>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MageFreeze> CreateMageFreeze(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t enemy_id = 0) {
        MageFreezeBuilder builder_(_fbb);
        builder_.add_enemy_id(enemy_id);
        return builder_.Finish();
    }
    
    struct Spell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_SPELL_TYPE = 4,
            VT_SPELL = 6
        };
        Spells spell_type() const {
            return static_cast<Spells>(GetField<uint8_t>(VT_SPELL_TYPE, 0));
        }
        const void *spell() const {
            return GetPointer<const void *>(VT_SPELL);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint8_t>(verifier, VT_SPELL_TYPE) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPELL) &&
            VerifySpells(verifier, spell(), spell_type()) &&
            verifier.EndTable();
        }
    };
    
    struct SpellBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_spell_type(Spells spell_type) {
            fbb_.AddElement<uint8_t>(Spell::VT_SPELL_TYPE, static_cast<uint8_t>(spell_type), 0);
        }
        void add_spell(flatbuffers::Offset<void> spell) {
            fbb_.AddOffset(Spell::VT_SPELL, spell);
        }
        SpellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SpellBuilder &operator=(const SpellBuilder &);
        flatbuffers::Offset<Spell> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<Spell>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<Spell> CreateSpell(
                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                  Spells spell_type = Spells_NONE,
                                                  flatbuffers::Offset<void> spell = 0) {
        SpellBuilder builder_(_fbb);
        builder_.add_spell(spell);
        builder_.add_spell_type(spell_type);
        return builder_.Finish();
    }
    
    struct CLActionSpell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_SPELL_ID = 6,
            VT_SPELL_INFO = 8
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        uint16_t spell_id() const {
            return GetField<uint16_t>(VT_SPELL_ID, 0);
        }
        const Spell *spell_info() const {
            return GetPointer<const Spell *>(VT_SPELL_INFO);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<uint16_t>(verifier, VT_SPELL_ID) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPELL_INFO) &&
            verifier.VerifyTable(spell_info()) &&
            verifier.EndTable();
        }
    };
    
    struct CLActionSpellBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLActionSpell::VT_PLAYER_UID, player_uid, 0);
        }
        void add_spell_id(uint16_t spell_id) {
            fbb_.AddElement<uint16_t>(CLActionSpell::VT_SPELL_ID, spell_id, 0);
        }
        void add_spell_info(flatbuffers::Offset<Spell> spell_info) {
            fbb_.AddOffset(CLActionSpell::VT_SPELL_INFO, spell_info);
        }
        CLActionSpellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLActionSpellBuilder &operator=(const CLActionSpellBuilder &);
        flatbuffers::Offset<CLActionSpell> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<CLActionSpell>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLActionSpell> CreateCLActionSpell(
                                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                                  uint32_t player_uid = 0,
                                                                  uint16_t spell_id = 0,
                                                                  flatbuffers::Offset<Spell> spell_info = 0) {
        CLActionSpellBuilder builder_(_fbb);
        builder_.add_spell_info(spell_info);
        builder_.add_player_uid(player_uid);
        builder_.add_spell_id(spell_id);
        return builder_.Finish();
    }
    
    struct SVActionSpell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_SPELL_ID = 6,
            VT_SPELL_INFO = 8
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        uint16_t spell_id() const {
            return GetField<uint16_t>(VT_SPELL_ID, 0);
        }
        const Spell *spell_info() const {
            return GetPointer<const Spell *>(VT_SPELL_INFO);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<uint16_t>(verifier, VT_SPELL_ID) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPELL_INFO) &&
            verifier.VerifyTable(spell_info()) &&
            verifier.EndTable();
        }
    };
    
    struct SVActionSpellBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVActionSpell::VT_PLAYER_UID, player_uid, 0);
        }
        void add_spell_id(uint16_t spell_id) {
            fbb_.AddElement<uint16_t>(SVActionSpell::VT_SPELL_ID, spell_id, 0);
        }
        void add_spell_info(flatbuffers::Offset<Spell> spell_info) {
            fbb_.AddOffset(SVActionSpell::VT_SPELL_INFO, spell_info);
        }
        SVActionSpellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVActionSpellBuilder &operator=(const SVActionSpellBuilder &);
        flatbuffers::Offset<SVActionSpell> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<SVActionSpell>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVActionSpell> CreateSVActionSpell(
                                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                                  uint32_t player_uid = 0,
                                                                  uint16_t spell_id = 0,
                                                                  flatbuffers::Offset<Spell> spell_info = 0) {
        SVActionSpellBuilder builder_(_fbb);
        builder_.add_spell_info(spell_info);
        builder_.add_player_uid(player_uid);
        builder_.add_spell_id(spell_id);
        return builder_.Finish();
    }
    
    struct CLActionAttack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_TARGET1_UID = 4,
            VT_TARGET2_UID = 6,
            VT_DAMAGE = 8,
            VT_MODIFICATORS = 10
        };
        uint32_t target1_uid() const {
            return GetField<uint32_t>(VT_TARGET1_UID, 0);
        }
        uint32_t target2_uid() const {
            return GetField<uint32_t>(VT_TARGET2_UID, 0);
        }
        uint16_t damage() const {
            return GetField<uint16_t>(VT_DAMAGE, 0);
        }
        int8_t modificators() const {
            return GetField<int8_t>(VT_MODIFICATORS, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_TARGET1_UID) &&
            VerifyField<uint32_t>(verifier, VT_TARGET2_UID) &&
            VerifyField<uint16_t>(verifier, VT_DAMAGE) &&
            VerifyField<int8_t>(verifier, VT_MODIFICATORS) &&
            verifier.EndTable();
        }
    };
    
    struct CLActionAttackBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_target1_uid(uint32_t target1_uid) {
            fbb_.AddElement<uint32_t>(CLActionAttack::VT_TARGET1_UID, target1_uid, 0);
        }
        void add_target2_uid(uint32_t target2_uid) {
            fbb_.AddElement<uint32_t>(CLActionAttack::VT_TARGET2_UID, target2_uid, 0);
        }
        void add_damage(uint16_t damage) {
            fbb_.AddElement<uint16_t>(CLActionAttack::VT_DAMAGE, damage, 0);
        }
        void add_modificators(int8_t modificators) {
            fbb_.AddElement<int8_t>(CLActionAttack::VT_MODIFICATORS, modificators, 0);
        }
        CLActionAttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLActionAttackBuilder &operator=(const CLActionAttackBuilder &);
        flatbuffers::Offset<CLActionAttack> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<CLActionAttack>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLActionAttack> CreateCLActionAttack(
                                                                    flatbuffers::FlatBufferBuilder &_fbb,
                                                                    uint32_t target1_uid = 0,
                                                                    uint32_t target2_uid = 0,
                                                                    uint16_t damage = 0,
                                                                    int8_t modificators = 0) {
        CLActionAttackBuilder builder_(_fbb);
        builder_.add_target2_uid(target2_uid);
        builder_.add_target1_uid(target1_uid);
        builder_.add_damage(damage);
        builder_.add_modificators(modificators);
        return builder_.Finish();
    }
    
    struct SVActionAttack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_TARGET1_UID = 4,
            VT_TARGET2_UID = 6,
            VT_DAMAGE = 8,
            VT_MODIFICATORS = 10
        };
        uint32_t target1_uid() const {
            return GetField<uint32_t>(VT_TARGET1_UID, 0);
        }
        uint32_t target2_uid() const {
            return GetField<uint32_t>(VT_TARGET2_UID, 0);
        }
        uint16_t damage() const {
            return GetField<uint16_t>(VT_DAMAGE, 0);
        }
        int8_t modificators() const {
            return GetField<int8_t>(VT_MODIFICATORS, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_TARGET1_UID) &&
            VerifyField<uint32_t>(verifier, VT_TARGET2_UID) &&
            VerifyField<uint16_t>(verifier, VT_DAMAGE) &&
            VerifyField<int8_t>(verifier, VT_MODIFICATORS) &&
            verifier.EndTable();
        }
    };
    
    struct SVActionAttackBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_target1_uid(uint32_t target1_uid) {
            fbb_.AddElement<uint32_t>(SVActionAttack::VT_TARGET1_UID, target1_uid, 0);
        }
        void add_target2_uid(uint32_t target2_uid) {
            fbb_.AddElement<uint32_t>(SVActionAttack::VT_TARGET2_UID, target2_uid, 0);
        }
        void add_damage(uint16_t damage) {
            fbb_.AddElement<uint16_t>(SVActionAttack::VT_DAMAGE, damage, 0);
        }
        void add_modificators(int8_t modificators) {
            fbb_.AddElement<int8_t>(SVActionAttack::VT_MODIFICATORS, modificators, 0);
        }
        SVActionAttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVActionAttackBuilder &operator=(const SVActionAttackBuilder &);
        flatbuffers::Offset<SVActionAttack> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<SVActionAttack>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVActionAttack> CreateSVActionAttack(
                                                                    flatbuffers::FlatBufferBuilder &_fbb,
                                                                    uint32_t target1_uid = 0,
                                                                    uint32_t target2_uid = 0,
                                                                    uint16_t damage = 0,
                                                                    int8_t modificators = 0) {
        SVActionAttackBuilder builder_(_fbb);
        builder_.add_target2_uid(target2_uid);
        builder_.add_target1_uid(target1_uid);
        builder_.add_damage(damage);
        builder_.add_modificators(modificators);
        return builder_.Finish();
    }
    
    struct CLActionDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_TARGET1_UID = 4,
            VT_TARGET2_UID = 6,
            VT_ACT_TYPE = 8,
            VT_DAMAGE = 10
        };
        uint32_t target1_uid() const {
            return GetField<uint32_t>(VT_TARGET1_UID, 0);
        }
        uint32_t target2_uid() const {
            return GetField<uint32_t>(VT_TARGET2_UID, 0);
        }
        ActionDuelType act_type() const {
            return static_cast<ActionDuelType>(GetField<int8_t>(VT_ACT_TYPE, 0));
        }
        uint16_t damage() const {
            return GetField<uint16_t>(VT_DAMAGE, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_TARGET1_UID) &&
            VerifyField<uint32_t>(verifier, VT_TARGET2_UID) &&
            VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
            VerifyField<uint16_t>(verifier, VT_DAMAGE) &&
            verifier.EndTable();
        }
    };
    
    struct CLActionDuelBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_target1_uid(uint32_t target1_uid) {
            fbb_.AddElement<uint32_t>(CLActionDuel::VT_TARGET1_UID, target1_uid, 0);
        }
        void add_target2_uid(uint32_t target2_uid) {
            fbb_.AddElement<uint32_t>(CLActionDuel::VT_TARGET2_UID, target2_uid, 0);
        }
        void add_act_type(ActionDuelType act_type) {
            fbb_.AddElement<int8_t>(CLActionDuel::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
        }
        void add_damage(uint16_t damage) {
            fbb_.AddElement<uint16_t>(CLActionDuel::VT_DAMAGE, damage, 0);
        }
        CLActionDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLActionDuelBuilder &operator=(const CLActionDuelBuilder &);
        flatbuffers::Offset<CLActionDuel> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<CLActionDuel>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLActionDuel> CreateCLActionDuel(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t target1_uid = 0,
                                                                uint32_t target2_uid = 0,
                                                                ActionDuelType act_type = ActionDuelType_STARTED,
                                                                uint16_t damage = 0) {
        CLActionDuelBuilder builder_(_fbb);
        builder_.add_target2_uid(target2_uid);
        builder_.add_target1_uid(target1_uid);
        builder_.add_damage(damage);
        builder_.add_act_type(act_type);
        return builder_.Finish();
    }
    
    struct SVActionDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_TARGET1_UID = 4,
            VT_TARGET2_UID = 6,
            VT_ACT_TYPE = 8,
            VT_DAMAGE = 10
        };
        uint32_t target1_uid() const {
            return GetField<uint32_t>(VT_TARGET1_UID, 0);
        }
        uint32_t target2_uid() const {
            return GetField<uint32_t>(VT_TARGET2_UID, 0);
        }
        ActionDuelType act_type() const {
            return static_cast<ActionDuelType>(GetField<int8_t>(VT_ACT_TYPE, 0));
        }
        uint16_t damage() const {
            return GetField<uint16_t>(VT_DAMAGE, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_TARGET1_UID) &&
            VerifyField<uint32_t>(verifier, VT_TARGET2_UID) &&
            VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
            VerifyField<uint16_t>(verifier, VT_DAMAGE) &&
            verifier.EndTable();
        }
    };
    
    struct SVActionDuelBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_target1_uid(uint32_t target1_uid) {
            fbb_.AddElement<uint32_t>(SVActionDuel::VT_TARGET1_UID, target1_uid, 0);
        }
        void add_target2_uid(uint32_t target2_uid) {
            fbb_.AddElement<uint32_t>(SVActionDuel::VT_TARGET2_UID, target2_uid, 0);
        }
        void add_act_type(ActionDuelType act_type) {
            fbb_.AddElement<int8_t>(SVActionDuel::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
        }
        void add_damage(uint16_t damage) {
            fbb_.AddElement<uint16_t>(SVActionDuel::VT_DAMAGE, damage, 0);
        }
        SVActionDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVActionDuelBuilder &operator=(const SVActionDuelBuilder &);
        flatbuffers::Offset<SVActionDuel> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<SVActionDuel>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVActionDuel> CreateSVActionDuel(
                                                                flatbuffers::FlatBufferBuilder &_fbb,
                                                                uint32_t target1_uid = 0,
                                                                uint32_t target2_uid = 0,
                                                                ActionDuelType act_type = ActionDuelType_STARTED,
                                                                uint16_t damage = 0) {
        SVActionDuelBuilder builder_(_fbb);
        builder_.add_target2_uid(target2_uid);
        builder_.add_target1_uid(target1_uid);
        builder_.add_damage(damage);
        builder_.add_act_type(act_type);
        return builder_.Finish();
    }
    
    struct CLActionMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_ACT_TYPE = 6,
            VT_X = 8,
            VT_Y = 10
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        ActionMapType act_type() const {
            return static_cast<ActionMapType>(GetField<int8_t>(VT_ACT_TYPE, 0));
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct CLActionMapBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLActionMap::VT_PLAYER_UID, player_uid, 0);
        }
        void add_act_type(ActionMapType act_type) {
            fbb_.AddElement<int8_t>(CLActionMap::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(CLActionMap::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(CLActionMap::VT_Y, y, 0);
        }
        CLActionMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLActionMapBuilder &operator=(const CLActionMapBuilder &);
        flatbuffers::Offset<CLActionMap> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<CLActionMap>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLActionMap> CreateCLActionMap(
                                                              flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint32_t player_uid = 0,
                                                              ActionMapType act_type = ActionMapType_CREATE_BLOCK,
                                                              uint16_t x = 0,
                                                              uint16_t y = 0) {
        CLActionMapBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_act_type(act_type);
        return builder_.Finish();
    }
    
    struct SVActionMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_ACT_TYPE = 6,
            VT_X = 8,
            VT_Y = 10
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        ActionMapType act_type() const {
            return static_cast<ActionMapType>(GetField<int8_t>(VT_ACT_TYPE, 0));
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct SVActionMapBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVActionMap::VT_PLAYER_UID, player_uid, 0);
        }
        void add_act_type(ActionMapType act_type) {
            fbb_.AddElement<int8_t>(SVActionMap::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVActionMap::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVActionMap::VT_Y, y, 0);
        }
        SVActionMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVActionMapBuilder &operator=(const SVActionMapBuilder &);
        flatbuffers::Offset<SVActionMap> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<SVActionMap>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVActionMap> CreateSVActionMap(
                                                              flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint32_t player_uid = 0,
                                                              ActionMapType act_type = ActionMapType_CREATE_BLOCK,
                                                              uint16_t x = 0,
                                                              uint16_t y = 0) {
        SVActionMapBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_act_type(act_type);
        return builder_.Finish();
    }
    
    struct SVSpawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_X = 6,
            VT_Y = 8,
            VT_HP = 10,
            VT_MAX_HP = 12
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        uint16_t hp() const {
            return GetField<uint16_t>(VT_HP, 0);
        }
        uint16_t max_hp() const {
            return GetField<uint16_t>(VT_MAX_HP, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            VerifyField<uint16_t>(verifier, VT_HP) &&
            VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
            verifier.EndTable();
        }
    };
    
    struct SVSpawnPlayerBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVSpawnPlayer::VT_PLAYER_UID, player_uid, 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_Y, y, 0);
        }
        void add_hp(uint16_t hp) {
            fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_HP, hp, 0);
        }
        void add_max_hp(uint16_t max_hp) {
            fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_MAX_HP, max_hp, 0);
        }
        SVSpawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVSpawnPlayerBuilder &operator=(const SVSpawnPlayerBuilder &);
        flatbuffers::Offset<SVSpawnPlayer> Finish() {
            const auto end = fbb_.EndTable(start_, 5);
            auto o = flatbuffers::Offset<SVSpawnPlayer>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVSpawnPlayer> CreateSVSpawnPlayer(
                                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                                  uint32_t player_uid = 0,
                                                                  uint16_t x = 0,
                                                                  uint16_t y = 0,
                                                                  uint16_t hp = 0,
                                                                  uint16_t max_hp = 0) {
        SVSpawnPlayerBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_max_hp(max_hp);
        builder_.add_hp(hp);
        builder_.add_y(y);
        builder_.add_x(x);
        return builder_.Finish();
    }
    
    struct SVSpawnMonster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_MONSTER_UID = 4,
            VT_X = 6,
            VT_Y = 8,
            VT_HP = 10,
            VT_MAX_HP = 12
        };
        uint16_t monster_uid() const {
            return GetField<uint16_t>(VT_MONSTER_UID, 0);
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        uint16_t hp() const {
            return GetField<uint16_t>(VT_HP, 0);
        }
        uint16_t max_hp() const {
            return GetField<uint16_t>(VT_MAX_HP, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint16_t>(verifier, VT_MONSTER_UID) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            VerifyField<uint16_t>(verifier, VT_HP) &&
            VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
            verifier.EndTable();
        }
    };
    
    struct SVSpawnMonsterBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_monster_uid(uint16_t monster_uid) {
            fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_MONSTER_UID, monster_uid, 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_Y, y, 0);
        }
        void add_hp(uint16_t hp) {
            fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_HP, hp, 0);
        }
        void add_max_hp(uint16_t max_hp) {
            fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_MAX_HP, max_hp, 0);
        }
        SVSpawnMonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVSpawnMonsterBuilder &operator=(const SVSpawnMonsterBuilder &);
        flatbuffers::Offset<SVSpawnMonster> Finish() {
            const auto end = fbb_.EndTable(start_, 5);
            auto o = flatbuffers::Offset<SVSpawnMonster>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVSpawnMonster> CreateSVSpawnMonster(
                                                                    flatbuffers::FlatBufferBuilder &_fbb,
                                                                    uint16_t monster_uid = 0,
                                                                    uint16_t x = 0,
                                                                    uint16_t y = 0,
                                                                    uint16_t hp = 0,
                                                                    uint16_t max_hp = 0) {
        SVSpawnMonsterBuilder builder_(_fbb);
        builder_.add_max_hp(max_hp);
        builder_.add_hp(hp);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_monster_uid(monster_uid);
        return builder_.Finish();
    }
    
    struct SVRespawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_X = 6,
            VT_Y = 8,
            VT_HP = 10,
            VT_MAX_HP = 12
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        uint16_t hp() const {
            return GetField<uint16_t>(VT_HP, 0);
        }
        uint16_t max_hp() const {
            return GetField<uint16_t>(VT_MAX_HP, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            VerifyField<uint16_t>(verifier, VT_HP) &&
            VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
            verifier.EndTable();
        }
    };
    
    struct SVRespawnPlayerBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVRespawnPlayer::VT_PLAYER_UID, player_uid, 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_Y, y, 0);
        }
        void add_hp(uint16_t hp) {
            fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_HP, hp, 0);
        }
        void add_max_hp(uint16_t max_hp) {
            fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_MAX_HP, max_hp, 0);
        }
        SVRespawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVRespawnPlayerBuilder &operator=(const SVRespawnPlayerBuilder &);
        flatbuffers::Offset<SVRespawnPlayer> Finish() {
            const auto end = fbb_.EndTable(start_, 5);
            auto o = flatbuffers::Offset<SVRespawnPlayer>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVRespawnPlayer> CreateSVRespawnPlayer(
                                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                                      uint32_t player_uid = 0,
                                                                      uint16_t x = 0,
                                                                      uint16_t y = 0,
                                                                      uint16_t hp = 0,
                                                                      uint16_t max_hp = 0) {
        SVRespawnPlayerBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_max_hp(max_hp);
        builder_.add_hp(hp);
        builder_.add_y(y);
        builder_.add_x(x);
        return builder_.Finish();
    }
    
    struct SVSpawnItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_ITEM_UID = 4,
            VT_ITEM_TYPE = 6,
            VT_X = 8,
            VT_Y = 10
        };
        uint16_t item_uid() const {
            return GetField<uint16_t>(VT_ITEM_UID, 0);
        }
        ItemType item_type() const {
            return static_cast<ItemType>(GetField<int8_t>(VT_ITEM_TYPE, 0));
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
            VerifyField<int8_t>(verifier, VT_ITEM_TYPE) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct SVSpawnItemBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_item_uid(uint16_t item_uid) {
            fbb_.AddElement<uint16_t>(SVSpawnItem::VT_ITEM_UID, item_uid, 0);
        }
        void add_item_type(ItemType item_type) {
            fbb_.AddElement<int8_t>(SVSpawnItem::VT_ITEM_TYPE, static_cast<int8_t>(item_type), 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVSpawnItem::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVSpawnItem::VT_Y, y, 0);
        }
        SVSpawnItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVSpawnItemBuilder &operator=(const SVSpawnItemBuilder &);
        flatbuffers::Offset<SVSpawnItem> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<SVSpawnItem>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVSpawnItem> CreateSVSpawnItem(
                                                              flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint16_t item_uid = 0,
                                                              ItemType item_type = ItemType_KEY,
                                                              uint16_t x = 0,
                                                              uint16_t y = 0) {
        SVSpawnItemBuilder builder_(_fbb);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_item_uid(item_uid);
        builder_.add_item_type(item_type);
        return builder_.Finish();
    }
    
    struct SVSpawnConstr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_CONSTR_UID = 4,
            VT_CONSTR_TYPE = 6,
            VT_X = 8,
            VT_Y = 10
        };
        uint16_t constr_uid() const {
            return GetField<uint16_t>(VT_CONSTR_UID, 0);
        }
        ConstrType constr_type() const {
            return static_cast<ConstrType>(GetField<int8_t>(VT_CONSTR_TYPE, 0));
        }
        uint16_t x() const {
            return GetField<uint16_t>(VT_X, 0);
        }
        uint16_t y() const {
            return GetField<uint16_t>(VT_Y, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint16_t>(verifier, VT_CONSTR_UID) &&
            VerifyField<int8_t>(verifier, VT_CONSTR_TYPE) &&
            VerifyField<uint16_t>(verifier, VT_X) &&
            VerifyField<uint16_t>(verifier, VT_Y) &&
            verifier.EndTable();
        }
    };
    
    struct SVSpawnConstrBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_constr_uid(uint16_t constr_uid) {
            fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_CONSTR_UID, constr_uid, 0);
        }
        void add_constr_type(ConstrType constr_type) {
            fbb_.AddElement<int8_t>(SVSpawnConstr::VT_CONSTR_TYPE, static_cast<int8_t>(constr_type), 0);
        }
        void add_x(uint16_t x) {
            fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_X, x, 0);
        }
        void add_y(uint16_t y) {
            fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_Y, y, 0);
        }
        SVSpawnConstrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVSpawnConstrBuilder &operator=(const SVSpawnConstrBuilder &);
        flatbuffers::Offset<SVSpawnConstr> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<SVSpawnConstr>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVSpawnConstr> CreateSVSpawnConstr(
                                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                                  uint16_t constr_uid = 0,
                                                                  ConstrType constr_type = ConstrType_DOOR,
                                                                  uint16_t x = 0,
                                                                  uint16_t y = 0) {
        SVSpawnConstrBuilder builder_(_fbb);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_constr_uid(constr_uid);
        builder_.add_constr_type(constr_type);
        return builder_.Finish();
    }
    
    struct SVGameEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            verifier.EndTable();
        }
    };
    
    struct SVGameEndBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVGameEnd::VT_PLAYER_UID, player_uid, 0);
        }
        SVGameEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVGameEndBuilder &operator=(const SVGameEndBuilder &);
        flatbuffers::Offset<SVGameEnd> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<SVGameEnd>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVGameEnd> CreateSVGameEnd(
                                                          flatbuffers::FlatBufferBuilder &_fbb,
                                                          uint32_t player_uid = 0) {
        SVGameEndBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        return builder_.Finish();
    }
    
    struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_EVENT_TYPE = 4,
            VT_EVENT = 6
        };
        Events event_type() const {
            return static_cast<Events>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
        }
        const void *event() const {
            return GetPointer<const void *>(VT_EVENT);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
            VerifyEvents(verifier, event(), event_type()) &&
            verifier.EndTable();
        }
    };
    
    struct MessageBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_event_type(Events event_type) {
            fbb_.AddElement<uint8_t>(Message::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
        }
        void add_event(flatbuffers::Offset<void> event) {
            fbb_.AddOffset(Message::VT_EVENT, event);
        }
        MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MessageBuilder &operator=(const MessageBuilder &);
        flatbuffers::Offset<Message> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<Message>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<Message> CreateMessage(
                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                      Events event_type = Events_NONE,
                                                      flatbuffers::Offset<void> event = 0) {
        MessageBuilder builder_(_fbb);
        builder_.add_event(event);
        builder_.add_event_type(event_type);
        return builder_.Finish();
    }
    
    inline bool VerifySpells(flatbuffers::Verifier &verifier, const void *obj, Spells type) {
        switch (type) {
            case Spells_NONE: {
                return true;
            }
            case Spells_MageTeleport: {
                auto ptr = reinterpret_cast<const MageTeleport *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Spells_MageFreeze: {
                auto ptr = reinterpret_cast<const MageFreeze *>(obj);
                return verifier.VerifyTable(ptr);
            }
            default: return false;
        }
    }
    
    inline bool VerifySpellsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
        if (values->size() != types->size()) return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifySpells(
                              verifier,  values->Get(i), types->GetEnum<Spells>(i))) {
                return false;
            }
        }
        return true;
    }
    
    inline bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type) {
        switch (type) {
            case Events_NONE: {
                return true;
            }
            case Events_CLConnection: {
                auto ptr = reinterpret_cast<const CLConnection *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVConnectionStatus: {
                auto ptr = reinterpret_cast<const SVConnectionStatus *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVPlayerConnected: {
                auto ptr = reinterpret_cast<const SVPlayerConnected *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVHeroPickStage: {
                auto ptr = reinterpret_cast<const SVHeroPickStage *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLHeroPick: {
                auto ptr = reinterpret_cast<const CLHeroPick *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVHeroPick: {
                auto ptr = reinterpret_cast<const SVHeroPick *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLReadyToStart: {
                auto ptr = reinterpret_cast<const CLReadyToStart *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVReadyToStart: {
                auto ptr = reinterpret_cast<const SVReadyToStart *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVGenerateMap: {
                auto ptr = reinterpret_cast<const SVGenerateMap *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLMapGenerated: {
                auto ptr = reinterpret_cast<const CLMapGenerated *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVGameStart: {
                auto ptr = reinterpret_cast<const SVGameStart *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLActionMove: {
                auto ptr = reinterpret_cast<const CLActionMove *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVActionMove: {
                auto ptr = reinterpret_cast<const SVActionMove *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLActionItem: {
                auto ptr = reinterpret_cast<const CLActionItem *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVActionItem: {
                auto ptr = reinterpret_cast<const SVActionItem *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLActionAttack: {
                auto ptr = reinterpret_cast<const CLActionAttack *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVActionAttack: {
                auto ptr = reinterpret_cast<const SVActionAttack *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLActionDuel: {
                auto ptr = reinterpret_cast<const CLActionDuel *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVActionDuel: {
                auto ptr = reinterpret_cast<const SVActionDuel *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLActionSpell: {
                auto ptr = reinterpret_cast<const CLActionSpell *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVActionSpell: {
                auto ptr = reinterpret_cast<const SVActionSpell *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_CLActionMap: {
                auto ptr = reinterpret_cast<const CLActionMap *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVActionMap: {
                auto ptr = reinterpret_cast<const SVActionMap *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVSpawnPlayer: {
                auto ptr = reinterpret_cast<const SVSpawnPlayer *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVRespawnPlayer: {
                auto ptr = reinterpret_cast<const SVRespawnPlayer *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVSpawnMonster: {
                auto ptr = reinterpret_cast<const SVSpawnMonster *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVSpawnItem: {
                auto ptr = reinterpret_cast<const SVSpawnItem *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVSpawnConstr: {
                auto ptr = reinterpret_cast<const SVSpawnConstr *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Events_SVGameEnd: {
                auto ptr = reinterpret_cast<const SVGameEnd *>(obj);
                return verifier.VerifyTable(ptr);
            }
            default: return false;
        }
    }
    
    inline bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
        if (values->size() != types->size()) return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyEvents(
                              verifier,  values->Get(i), types->GetEnum<Events>(i))) {
                return false;
            }
        }
        return true;
    }
    
    inline const GameEvent::Message *GetMessage(const void *buf) {
        return flatbuffers::GetRoot<GameEvent::Message>(buf);
    }
    
    inline bool VerifyMessageBuffer(
                                    flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<GameEvent::Message>(nullptr);
    }
    
    inline void FinishMessageBuffer(
                                    flatbuffers::FlatBufferBuilder &fbb,
                                    flatbuffers::Offset<GameEvent::Message> root) {
        fbb.Finish(root);
    }
    
}  // namespace GameEvent

#endif  // FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_
