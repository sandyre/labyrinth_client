    // automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MSNET_MSNET_H_
#define FLATBUFFERS_GENERATED_MSNET_MSNET_H_

#include <mflatbuffers/flatbuffers.h>


namespace MSNet {
    
    struct CLPing;
    
    struct MSPing;
    
    struct CLRegister;
    
    struct SVRegister;
    
    struct CLLogin;
    
    struct SVLogin;
    
    struct CLFindGame;
    
    struct SVFindGame;
    
    struct MSGameFound;
    
    struct MSEvent;
    
    enum RegistrationStatus {
        RegistrationStatus_SUCCESS = 0,
        RegistrationStatus_EMAIL_TAKEN = 1,
        RegistrationStatus_MIN = RegistrationStatus_SUCCESS,
        RegistrationStatus_MAX = RegistrationStatus_EMAIL_TAKEN
    };
    
    inline const char **EnumNamesRegistrationStatus() {
        static const char *names[] = {
            "SUCCESS",
            "EMAIL_TAKEN",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameRegistrationStatus(RegistrationStatus e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesRegistrationStatus()[index];
    }
    
    enum LoginStatus {
        LoginStatus_SUCCESS = 0,
        LoginStatus_WRONG_INPUT = 1,
        LoginStatus_MIN = LoginStatus_SUCCESS,
        LoginStatus_MAX = LoginStatus_WRONG_INPUT
    };
    
    inline const char **EnumNamesLoginStatus() {
        static const char *names[] = {
            "SUCCESS",
            "WRONG_INPUT",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameLoginStatus(LoginStatus e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesLoginStatus()[index];
    }
    
    enum ConnectionResponse {
        ConnectionResponse_ACCEPTED = 0,
        ConnectionResponse_REFUSED = 1,
        ConnectionResponse_MIN = ConnectionResponse_ACCEPTED,
        ConnectionResponse_MAX = ConnectionResponse_REFUSED
    };
    
    inline const char **EnumNamesConnectionResponse() {
        static const char *names[] = {
            "ACCEPTED",
            "REFUSED",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameConnectionResponse(ConnectionResponse e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesConnectionResponse()[index];
    }
    
    enum MSEvents {
        MSEvents_NONE = 0,
        MSEvents_CLPing = 1,
        MSEvents_MSPing = 2,
        MSEvents_CLRegister = 3,
        MSEvents_SVRegister = 4,
        MSEvents_CLLogin = 5,
        MSEvents_SVLogin = 6,
        MSEvents_CLFindGame = 7,
        MSEvents_SVFindGame = 8,
        MSEvents_MSGameFound = 9,
        MSEvents_MIN = MSEvents_NONE,
        MSEvents_MAX = MSEvents_MSGameFound
    };
    
    inline const char **EnumNamesMSEvents() {
        static const char *names[] = {
            "NONE",
            "CLPing",
            "MSPing",
            "CLRegister",
            "SVRegister",
            "CLLogin",
            "SVLogin",
            "CLFindGame",
            "SVFindGame",
            "MSGameFound",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameMSEvents(MSEvents e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesMSEvents()[index];
    }
    
    template<typename T> struct MSEventsTraits {
        static const MSEvents enum_value = MSEvents_NONE;
    };
    
    template<> struct MSEventsTraits<CLPing> {
        static const MSEvents enum_value = MSEvents_CLPing;
    };
    
    template<> struct MSEventsTraits<MSPing> {
        static const MSEvents enum_value = MSEvents_MSPing;
    };
    
    template<> struct MSEventsTraits<CLRegister> {
        static const MSEvents enum_value = MSEvents_CLRegister;
    };
    
    template<> struct MSEventsTraits<SVRegister> {
        static const MSEvents enum_value = MSEvents_SVRegister;
    };
    
    template<> struct MSEventsTraits<CLLogin> {
        static const MSEvents enum_value = MSEvents_CLLogin;
    };
    
    template<> struct MSEventsTraits<SVLogin> {
        static const MSEvents enum_value = MSEvents_SVLogin;
    };
    
    template<> struct MSEventsTraits<CLFindGame> {
        static const MSEvents enum_value = MSEvents_CLFindGame;
    };
    
    template<> struct MSEventsTraits<SVFindGame> {
        static const MSEvents enum_value = MSEvents_SVFindGame;
    };
    
    template<> struct MSEventsTraits<MSGameFound> {
        static const MSEvents enum_value = MSEvents_MSGameFound;
    };
    
    bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type);
    bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
    
    struct CLPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            verifier.EndTable();
        }
    };
    
    struct CLPingBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        CLPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLPingBuilder &operator=(const CLPingBuilder &);
        flatbuffers::Offset<CLPing> Finish() {
            const auto end = fbb_.EndTable(start_, 0);
            auto o = flatbuffers::Offset<CLPing>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLPing> CreateCLPing(
                                                    flatbuffers::FlatBufferBuilder &_fbb) {
        CLPingBuilder builder_(_fbb);
        return builder_.Finish();
    }
    
    struct MSPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            verifier.EndTable();
        }
    };
    
    struct MSPingBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        MSPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MSPingBuilder &operator=(const MSPingBuilder &);
        flatbuffers::Offset<MSPing> Finish() {
            const auto end = fbb_.EndTable(start_, 0);
            auto o = flatbuffers::Offset<MSPing>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MSPing> CreateMSPing(
                                                    flatbuffers::FlatBufferBuilder &_fbb) {
        MSPingBuilder builder_(_fbb);
        return builder_.Finish();
    }
    
    struct CLRegister FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_EMAIL = 4,
            VT_PASSWORD = 6
        };
        const flatbuffers::String *email() const {
            return GetPointer<const flatbuffers::String *>(VT_EMAIL);
        }
        const flatbuffers::String *password() const {
            return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMAIL) &&
            verifier.Verify(email()) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
            verifier.Verify(password()) &&
            verifier.EndTable();
        }
    };
    
    struct CLRegisterBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_email(flatbuffers::Offset<flatbuffers::String> email) {
            fbb_.AddOffset(CLRegister::VT_EMAIL, email);
        }
        void add_password(flatbuffers::Offset<flatbuffers::String> password) {
            fbb_.AddOffset(CLRegister::VT_PASSWORD, password);
        }
        CLRegisterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLRegisterBuilder &operator=(const CLRegisterBuilder &);
        flatbuffers::Offset<CLRegister> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<CLRegister>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLRegister> CreateCLRegister(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            flatbuffers::Offset<flatbuffers::String> email = 0,
                                                            flatbuffers::Offset<flatbuffers::String> password = 0) {
        CLRegisterBuilder builder_(_fbb);
        builder_.add_password(password);
        builder_.add_email(email);
        return builder_.Finish();
    }
    
    inline flatbuffers::Offset<CLRegister> CreateCLRegisterDirect(
                                                                  flatbuffers::FlatBufferBuilder &_fbb,
                                                                  const char *email = nullptr,
                                                                  const char *password = nullptr) {
        return CreateCLRegister(
                                _fbb,
                                email ? _fbb.CreateString(email) : 0,
                                password ? _fbb.CreateString(password) : 0);
    }
    
    struct SVRegister FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_RESPONSE = 4
        };
        RegistrationStatus response() const {
            return static_cast<RegistrationStatus>(GetField<int8_t>(VT_RESPONSE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<int8_t>(verifier, VT_RESPONSE) &&
            verifier.EndTable();
        }
    };
    
    struct SVRegisterBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_response(RegistrationStatus response) {
            fbb_.AddElement<int8_t>(SVRegister::VT_RESPONSE, static_cast<int8_t>(response), 0);
        }
        SVRegisterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVRegisterBuilder &operator=(const SVRegisterBuilder &);
        flatbuffers::Offset<SVRegister> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<SVRegister>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVRegister> CreateSVRegister(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            RegistrationStatus response = RegistrationStatus_SUCCESS) {
        SVRegisterBuilder builder_(_fbb);
        builder_.add_response(response);
        return builder_.Finish();
    }
    
    struct CLLogin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_EMAIL = 4,
            VT_PASSWORD = 6
        };
        const flatbuffers::String *email() const {
            return GetPointer<const flatbuffers::String *>(VT_EMAIL);
        }
        const flatbuffers::String *password() const {
            return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMAIL) &&
            verifier.Verify(email()) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
            verifier.Verify(password()) &&
            verifier.EndTable();
        }
    };
    
    struct CLLoginBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_email(flatbuffers::Offset<flatbuffers::String> email) {
            fbb_.AddOffset(CLLogin::VT_EMAIL, email);
        }
        void add_password(flatbuffers::Offset<flatbuffers::String> password) {
            fbb_.AddOffset(CLLogin::VT_PASSWORD, password);
        }
        CLLoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLLoginBuilder &operator=(const CLLoginBuilder &);
        flatbuffers::Offset<CLLogin> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<CLLogin>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLLogin> CreateCLLogin(
                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                      flatbuffers::Offset<flatbuffers::String> email = 0,
                                                      flatbuffers::Offset<flatbuffers::String> password = 0) {
        CLLoginBuilder builder_(_fbb);
        builder_.add_password(password);
        builder_.add_email(email);
        return builder_.Finish();
    }
    
    inline flatbuffers::Offset<CLLogin> CreateCLLoginDirect(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            const char *email = nullptr,
                                                            const char *password = nullptr) {
        return CreateCLLogin(
                             _fbb,
                             email ? _fbb.CreateString(email) : 0,
                             password ? _fbb.CreateString(password) : 0);
    }
    
    struct SVLogin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_RESPONSE = 4
        };
        LoginStatus response() const {
            return static_cast<LoginStatus>(GetField<int8_t>(VT_RESPONSE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<int8_t>(verifier, VT_RESPONSE) &&
            verifier.EndTable();
        }
    };
    
    struct SVLoginBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_response(LoginStatus response) {
            fbb_.AddElement<int8_t>(SVLogin::VT_RESPONSE, static_cast<int8_t>(response), 0);
        }
        SVLoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVLoginBuilder &operator=(const SVLoginBuilder &);
        flatbuffers::Offset<SVLogin> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<SVLogin>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVLogin> CreateSVLogin(
                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                      LoginStatus response = LoginStatus_SUCCESS) {
        SVLoginBuilder builder_(_fbb);
        builder_.add_response(response);
        return builder_.Finish();
    }
    
    struct CLFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_CL_VERSION_MAJOR = 6,
            VT_CL_VERSION_MINOR = 8,
            VT_CL_VERSION_BUILD = 10
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        int8_t cl_version_major() const {
            return GetField<int8_t>(VT_CL_VERSION_MAJOR, 0);
        }
        int8_t cl_version_minor() const {
            return GetField<int8_t>(VT_CL_VERSION_MINOR, 0);
        }
        int8_t cl_version_build() const {
            return GetField<int8_t>(VT_CL_VERSION_BUILD, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_CL_VERSION_MAJOR) &&
            VerifyField<int8_t>(verifier, VT_CL_VERSION_MINOR) &&
            VerifyField<int8_t>(verifier, VT_CL_VERSION_BUILD) &&
            verifier.EndTable();
        }
    };
    
    struct CLFindGameBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLFindGame::VT_PLAYER_UID, player_uid, 0);
        }
        void add_cl_version_major(int8_t cl_version_major) {
            fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_MAJOR, cl_version_major, 0);
        }
        void add_cl_version_minor(int8_t cl_version_minor) {
            fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_MINOR, cl_version_minor, 0);
        }
        void add_cl_version_build(int8_t cl_version_build) {
            fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_BUILD, cl_version_build, 0);
        }
        CLFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLFindGameBuilder &operator=(const CLFindGameBuilder &);
        flatbuffers::Offset<CLFindGame> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<CLFindGame>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLFindGame> CreateCLFindGame(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t player_uid = 0,
                                                            int8_t cl_version_major = 0,
                                                            int8_t cl_version_minor = 0,
                                                            int8_t cl_version_build = 0) {
        CLFindGameBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_cl_version_build(cl_version_build);
        builder_.add_cl_version_minor(cl_version_minor);
        builder_.add_cl_version_major(cl_version_major);
        return builder_.Finish();
    }
    
    struct SVFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_RESPONSE = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        ConnectionResponse response() const {
            return static_cast<ConnectionResponse>(GetField<int8_t>(VT_RESPONSE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_RESPONSE) &&
            verifier.EndTable();
        }
    };
    
    struct SVFindGameBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVFindGame::VT_PLAYER_UID, player_uid, 0);
        }
        void add_response(ConnectionResponse response) {
            fbb_.AddElement<int8_t>(SVFindGame::VT_RESPONSE, static_cast<int8_t>(response), 0);
        }
        SVFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVFindGameBuilder &operator=(const SVFindGameBuilder &);
        flatbuffers::Offset<SVFindGame> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<SVFindGame>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVFindGame> CreateSVFindGame(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t player_uid = 0,
                                                            ConnectionResponse response = ConnectionResponse_ACCEPTED) {
        SVFindGameBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_response(response);
        return builder_.Finish();
    }
    
    struct MSGameFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_GS_PORT = 4
        };
        uint32_t gs_port() const {
            return GetField<uint32_t>(VT_GS_PORT, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_GS_PORT) &&
            verifier.EndTable();
        }
    };
    
    struct MSGameFoundBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_gs_port(uint32_t gs_port) {
            fbb_.AddElement<uint32_t>(MSGameFound::VT_GS_PORT, gs_port, 0);
        }
        MSGameFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MSGameFoundBuilder &operator=(const MSGameFoundBuilder &);
        flatbuffers::Offset<MSGameFound> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<MSGameFound>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MSGameFound> CreateMSGameFound(
                                                              flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint32_t gs_port = 0) {
        MSGameFoundBuilder builder_(_fbb);
        builder_.add_gs_port(gs_port);
        return builder_.Finish();
    }
    
    struct MSEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_EVENT_TYPE = 4,
            VT_EVENT = 6
        };
        MSEvents event_type() const {
            return static_cast<MSEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
        }
        const void *event() const {
            return GetPointer<const void *>(VT_EVENT);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
            VerifyMSEvents(verifier, event(), event_type()) &&
            verifier.EndTable();
        }
    };
    
    struct MSEventBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_event_type(MSEvents event_type) {
            fbb_.AddElement<uint8_t>(MSEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
        }
        void add_event(flatbuffers::Offset<void> event) {
            fbb_.AddOffset(MSEvent::VT_EVENT, event);
        }
        MSEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MSEventBuilder &operator=(const MSEventBuilder &);
        flatbuffers::Offset<MSEvent> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<MSEvent>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MSEvent> CreateMSEvent(
                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                      MSEvents event_type = MSEvents_NONE,
                                                      flatbuffers::Offset<void> event = 0) {
        MSEventBuilder builder_(_fbb);
        builder_.add_event(event);
        builder_.add_event_type(event_type);
        return builder_.Finish();
    }
    
    inline bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type) {
        switch (type) {
            case MSEvents_NONE: {
                return true;
            }
            case MSEvents_CLPing: {
                auto ptr = reinterpret_cast<const CLPing *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_MSPing: {
                auto ptr = reinterpret_cast<const MSPing *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_CLRegister: {
                auto ptr = reinterpret_cast<const CLRegister *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_SVRegister: {
                auto ptr = reinterpret_cast<const SVRegister *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_CLLogin: {
                auto ptr = reinterpret_cast<const CLLogin *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_SVLogin: {
                auto ptr = reinterpret_cast<const SVLogin *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_CLFindGame: {
                auto ptr = reinterpret_cast<const CLFindGame *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_SVFindGame: {
                auto ptr = reinterpret_cast<const SVFindGame *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_MSGameFound: {
                auto ptr = reinterpret_cast<const MSGameFound *>(obj);
                return verifier.VerifyTable(ptr);
            }
            default: return false;
        }
    }
    
    inline bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
        if (values->size() != types->size()) return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyMSEvents(
                                verifier,  values->Get(i), types->GetEnum<MSEvents>(i))) {
                return false;
            }
        }
        return true;
    }
    
    inline const MSNet::MSEvent *GetMSEvent(const void *buf) {
        return flatbuffers::GetRoot<MSNet::MSEvent>(buf);
    }
    
    inline bool VerifyMSEventBuffer(
                                    flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<MSNet::MSEvent>(nullptr);
    }
    
    inline void FinishMSEventBuffer(
                                    flatbuffers::FlatBufferBuilder &fbb,
                                    flatbuffers::Offset<MSNet::MSEvent> root) {
        fbb.Finish(root);
    }
    
}  // namespace MSNet

#endif  // FLATBUFFERS_GENERATED_MSNET_MSNET_H_
