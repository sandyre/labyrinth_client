    // automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MSNET_MSNET_H_
#define FLATBUFFERS_GENERATED_MSNET_MSNET_H_

#include <mflatbuffers/flatbuffers.h>

namespace MSNet {
    
    struct CLPing;
    
    struct MSPing;
    
    struct CLFindGame;
    
    struct SVFindGame;
    
    struct MSGameFound;
    
    struct MSEvent;
    
    enum Type {
        Type_CL_PING = 0,
        Type_MS_PING = 1,
        Type_CL_FIND_GAME = 2,
        Type_MS_GAME_FOUND = 3,
        Type_MIN = Type_CL_PING,
        Type_MAX = Type_MS_GAME_FOUND
    };
    
    inline const char **EnumNamesType() {
        static const char *names[] = {
            "CL_PING",
            "MS_PING",
            "CL_FIND_GAME",
            "MS_GAME_FOUND",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameType(Type e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesType()[index];
    }
    
    enum ConnectionResponse {
        ConnectionResponse_ACCEPTED = 0,
        ConnectionResponse_REFUSED = 1,
        ConnectionResponse_MIN = ConnectionResponse_ACCEPTED,
        ConnectionResponse_MAX = ConnectionResponse_REFUSED
    };
    
    inline const char **EnumNamesConnectionResponse() {
        static const char *names[] = {
            "ACCEPTED",
            "REFUSED",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameConnectionResponse(ConnectionResponse e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesConnectionResponse()[index];
    }
    
    enum MSEvents {
        MSEvents_NONE = 0,
        MSEvents_CLPing = 1,
        MSEvents_MSPing = 2,
        MSEvents_CLFindGame = 3,
        MSEvents_SVFindGame = 4,
        MSEvents_MSGameFound = 5,
        MSEvents_MIN = MSEvents_NONE,
        MSEvents_MAX = MSEvents_MSGameFound
    };
    
    inline const char **EnumNamesMSEvents() {
        static const char *names[] = {
            "NONE",
            "CLPing",
            "MSPing",
            "CLFindGame",
            "SVFindGame",
            "MSGameFound",
            nullptr
        };
        return names;
    }
    
    inline const char *EnumNameMSEvents(MSEvents e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesMSEvents()[index];
    }
    
    template<typename T> struct MSEventsTraits {
        static const MSEvents enum_value = MSEvents_NONE;
    };
    
    template<> struct MSEventsTraits<CLPing> {
        static const MSEvents enum_value = MSEvents_CLPing;
    };
    
    template<> struct MSEventsTraits<MSPing> {
        static const MSEvents enum_value = MSEvents_MSPing;
    };
    
    template<> struct MSEventsTraits<CLFindGame> {
        static const MSEvents enum_value = MSEvents_CLFindGame;
    };
    
    template<> struct MSEventsTraits<SVFindGame> {
        static const MSEvents enum_value = MSEvents_SVFindGame;
    };
    
    template<> struct MSEventsTraits<MSGameFound> {
        static const MSEvents enum_value = MSEvents_MSGameFound;
    };
    
    bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type);
    bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
    
    struct CLPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            verifier.EndTable();
        }
    };
    
    struct CLPingBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        CLPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLPingBuilder &operator=(const CLPingBuilder &);
        flatbuffers::Offset<CLPing> Finish() {
            const auto end = fbb_.EndTable(start_, 0);
            auto o = flatbuffers::Offset<CLPing>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLPing> CreateCLPing(
                                                    flatbuffers::FlatBufferBuilder &_fbb) {
        CLPingBuilder builder_(_fbb);
        return builder_.Finish();
    }
    
    struct MSPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            verifier.EndTable();
        }
    };
    
    struct MSPingBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        MSPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MSPingBuilder &operator=(const MSPingBuilder &);
        flatbuffers::Offset<MSPing> Finish() {
            const auto end = fbb_.EndTable(start_, 0);
            auto o = flatbuffers::Offset<MSPing>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MSPing> CreateMSPing(
                                                    flatbuffers::FlatBufferBuilder &_fbb) {
        MSPingBuilder builder_(_fbb);
        return builder_.Finish();
    }
    
    struct CLFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_CL_VERSION_MAJOR = 6,
            VT_CL_VERSION_MINOR = 8,
            VT_CL_VERSION_BUILD = 10
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        int8_t cl_version_major() const {
            return GetField<int8_t>(VT_CL_VERSION_MAJOR, 0);
        }
        int8_t cl_version_minor() const {
            return GetField<int8_t>(VT_CL_VERSION_MINOR, 0);
        }
        int8_t cl_version_build() const {
            return GetField<int8_t>(VT_CL_VERSION_BUILD, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_CL_VERSION_MAJOR) &&
            VerifyField<int8_t>(verifier, VT_CL_VERSION_MINOR) &&
            VerifyField<int8_t>(verifier, VT_CL_VERSION_BUILD) &&
            verifier.EndTable();
        }
    };
    
    struct CLFindGameBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(CLFindGame::VT_PLAYER_UID, player_uid, 0);
        }
        void add_cl_version_major(int8_t cl_version_major) {
            fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_MAJOR, cl_version_major, 0);
        }
        void add_cl_version_minor(int8_t cl_version_minor) {
            fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_MINOR, cl_version_minor, 0);
        }
        void add_cl_version_build(int8_t cl_version_build) {
            fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_BUILD, cl_version_build, 0);
        }
        CLFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        CLFindGameBuilder &operator=(const CLFindGameBuilder &);
        flatbuffers::Offset<CLFindGame> Finish() {
            const auto end = fbb_.EndTable(start_, 4);
            auto o = flatbuffers::Offset<CLFindGame>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<CLFindGame> CreateCLFindGame(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t player_uid = 0,
                                                            int8_t cl_version_major = 0,
                                                            int8_t cl_version_minor = 0,
                                                            int8_t cl_version_build = 0) {
        CLFindGameBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_cl_version_build(cl_version_build);
        builder_.add_cl_version_minor(cl_version_minor);
        builder_.add_cl_version_major(cl_version_major);
        return builder_.Finish();
    }
    
    struct SVFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_PLAYER_UID = 4,
            VT_RESPONSE = 6
        };
        uint32_t player_uid() const {
            return GetField<uint32_t>(VT_PLAYER_UID, 0);
        }
        ConnectionResponse response() const {
            return static_cast<ConnectionResponse>(GetField<int8_t>(VT_RESPONSE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
            VerifyField<int8_t>(verifier, VT_RESPONSE) &&
            verifier.EndTable();
        }
    };
    
    struct SVFindGameBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_uid(uint32_t player_uid) {
            fbb_.AddElement<uint32_t>(SVFindGame::VT_PLAYER_UID, player_uid, 0);
        }
        void add_response(ConnectionResponse response) {
            fbb_.AddElement<int8_t>(SVFindGame::VT_RESPONSE, static_cast<int8_t>(response), 0);
        }
        SVFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SVFindGameBuilder &operator=(const SVFindGameBuilder &);
        flatbuffers::Offset<SVFindGame> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<SVFindGame>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<SVFindGame> CreateSVFindGame(
                                                            flatbuffers::FlatBufferBuilder &_fbb,
                                                            uint32_t player_uid = 0,
                                                            ConnectionResponse response = ConnectionResponse_ACCEPTED) {
        SVFindGameBuilder builder_(_fbb);
        builder_.add_player_uid(player_uid);
        builder_.add_response(response);
        return builder_.Finish();
    }
    
    struct MSGameFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_GS_PORT = 4
        };
        uint32_t gs_port() const {
            return GetField<uint32_t>(VT_GS_PORT, 0);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint32_t>(verifier, VT_GS_PORT) &&
            verifier.EndTable();
        }
    };
    
    struct MSGameFoundBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_gs_port(uint32_t gs_port) {
            fbb_.AddElement<uint32_t>(MSGameFound::VT_GS_PORT, gs_port, 0);
        }
        MSGameFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MSGameFoundBuilder &operator=(const MSGameFoundBuilder &);
        flatbuffers::Offset<MSGameFound> Finish() {
            const auto end = fbb_.EndTable(start_, 1);
            auto o = flatbuffers::Offset<MSGameFound>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MSGameFound> CreateMSGameFound(
                                                              flatbuffers::FlatBufferBuilder &_fbb,
                                                              uint32_t gs_port = 0) {
        MSGameFoundBuilder builder_(_fbb);
        builder_.add_gs_port(gs_port);
        return builder_.Finish();
    }
    
    struct MSEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_EVENT_TYPE = 4,
            VT_EVENT = 6
        };
        MSEvents event_type() const {
            return static_cast<MSEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
        }
        const void *event() const {
            return GetPointer<const void *>(VT_EVENT);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
            VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
            VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
            VerifyMSEvents(verifier, event(), event_type()) &&
            verifier.EndTable();
        }
    };
    
    struct MSEventBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_event_type(MSEvents event_type) {
            fbb_.AddElement<uint8_t>(MSEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
        }
        void add_event(flatbuffers::Offset<void> event) {
            fbb_.AddOffset(MSEvent::VT_EVENT, event);
        }
        MSEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        MSEventBuilder &operator=(const MSEventBuilder &);
        flatbuffers::Offset<MSEvent> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<MSEvent>(end);
            return o;
        }
    };
    
    inline flatbuffers::Offset<MSEvent> CreateMSEvent(
                                                      flatbuffers::FlatBufferBuilder &_fbb,
                                                      MSEvents event_type = MSEvents_NONE,
                                                      flatbuffers::Offset<void> event = 0) {
        MSEventBuilder builder_(_fbb);
        builder_.add_event(event);
        builder_.add_event_type(event_type);
        return builder_.Finish();
    }
    
    inline bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type) {
        switch (type) {
            case MSEvents_NONE: {
                return true;
            }
            case MSEvents_CLPing: {
                auto ptr = reinterpret_cast<const CLPing *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_MSPing: {
                auto ptr = reinterpret_cast<const MSPing *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_CLFindGame: {
                auto ptr = reinterpret_cast<const CLFindGame *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_SVFindGame: {
                auto ptr = reinterpret_cast<const SVFindGame *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MSEvents_MSGameFound: {
                auto ptr = reinterpret_cast<const MSGameFound *>(obj);
                return verifier.VerifyTable(ptr);
            }
            default: return false;
        }
    }
    
    inline bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
        if (values->size() != types->size()) return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyMSEvents(
                                verifier,  values->Get(i), types->GetEnum<MSEvents>(i))) {
                return false;
            }
        }
        return true;
    }
    
    inline const MSNet::MSEvent *GetMSEvent(const void *buf) {
        return flatbuffers::GetRoot<MSNet::MSEvent>(buf);
    }
    
    inline bool VerifyMSEventBuffer(
                                    flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<MSNet::MSEvent>(nullptr);
    }
    
    inline void FinishMSEventBuffer(
                                    flatbuffers::FlatBufferBuilder &fbb,
                                    flatbuffers::Offset<MSNet::MSEvent> root) {
        fbb.Finish(root);
    }
    
}  // namespace MSNet

#endif  // FLATBUFFERS_GENERATED_MSNET_MSNET_H_
